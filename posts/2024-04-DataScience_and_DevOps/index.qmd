---
title: "Commits atômicos e profissionais de dados"
subtitle: "Aprenda a commitar e entenda porque um profissional de dados precisa dar atenção a isto."
author: 
   - "[Ían Muliterno](https://imuliterno.netlify.app/)" 
date: "2024-07-31" 
categories: 
# exemplo de categorias:
  - "Tutorial"
toc: true # isso habilita o sumário ao lado do post
image: "images/logo.jpg" # imagem usada na página inicial junto ao post
bibliography: "pacotes.bib" # arquivo de bibliografia. Pode adicionar mais arquivos!
draft: FALSE
---

::: {.callout-note collapse="false"}
## Autoria

<center>

![Foto](https://avatars.githubusercontent.com/u/21000314?v=4){style="width: 30%; border-radius: 50%;"}

[<i class="bi bi-house-fill"></i>](https://) [<i class="fab fa-github"></i>](https://github.com/USER) [<i class="fab fa-linkedin"></i>](https://www.linkedin.com/in/USER/) [<i class="fab fa-instagram"></i>](https://www.instagram.com/USER/)

</center>

Este post foi escrito por Ían Muliterno, co-organizador da comunidade R-ladies São Paulo. Ían é formado em estatística pela UFPE e trabalha como cientista de dados/ML engineer. Além da área de dados, também é autor do livro "Diversidade - Apenas mais uma virtude", disponível na Amazon Kindle.
:::

## Introdução

Com a evolução da área de ciência de dados e machine learning, a integração das práticas de DevOps se tornam cada vez mais essenciais. Se você duvida, basta dar uma olhada no conceito de DevOps e pensar como seria possível fazer o deploy de modelos e trabalhar em cloud, sem a aplicação desses conceitos básicos para um desenvolvedor de software.

DevOps é uma combinação das palavras "Desenvolvimento" e "Operações". É uma estratégia que une os times que criam um software com o time que garante que o software funciona bem para o usuário final. O principal objetivo dessa estratégia é acelerar o processo de entrega de um software de qualidade.

Os principais pilares do DevOps são:

1.  Automação
2.  CI/CD
3.  Colaboração
4.  Teste e monitoramento
5.  IaC

**Automação**: fazer com que tarefas repetitivas rodem por si só.

**Continuous Integration and Continuous Deployment (CI/CD)**: Adicionar mudanças pequenas de maneira constante e imediatamente deixando-as prontas para serem consumidas pelo usuário final.

**Colaboração**: Envolvimento de todos aqueles responsáveis pelo projeto, do rascunho até o lançamento. Isso garante soluções mais rápidas.

**Teste e monitoramento**: Testar sempre, especialmente novas features. Os `unit test` são cruciais nesse momento, pois, uma vez setados rodam automaticamente e avisam em caso de erro, pode ser feito por ferramentas como github actions ou Azure DevOps services.

**Infraestrutura como Código (IaC)**: Setar servidores de um jeito tão simples quanto escrever um script de código.

#### E onde entram os commits atômicos nessa história?

Primeiro de tudo, commit é o registro de alguma mudança no seu controle de versionamento. Um commit atômico é uma prática onde cada commit contém uma única mudança funcional. Então nada de passar o dia codando e só commitar no fim do dia, imagina ter que reverter uma única coisa feita nesse dia, e precisar fazer `undo` do commit inteiro?! Nesta prática o ideal é, por exemplo, commitar cada nova feature, cada novo módulo ou função. Além disso, um commit atômico deve ser capaz de passar em todos os testes, para assegurar que ele não quebra o código base do seu projeto.

#### Porquê commits atômicos?

**1. Clareza:** Commits atômicos facilitam e dividem com clareza as mudanças históricas, isso é muito importante para debug e colaboração.

**2. Revertibilidade:** Com o commit constante marcando cada pequena mudança completa, por exemplo, a criação de uma função ou botão num aplicativo, é mais fácil reverter algo sem impactar outras partes do projeto.

**3. Revisão de código:** Mudanças menores, bem definidas e documentadas também facilitam a revisão de código

#### Exemplo de commits atômicos

Vamos considerar um projeto onde queremos criar um modelo que prevê churn. Estes são alguns exemplos de commits atômicos.

-   **Commit 1:** \[ Nova feature \] calcular "tempo de casa" do cliente.
-   **Commit 2:** \[ Implementando modelo \] Regressão logística.
-   **Commit 3:** \[ Debug \] Onde o cálculo de "tempo de casa" retornou NaN por conta de valores faltantes.

Cada commit aborda uma única tarefa ou debug e estão bem documentados, o que os tornam commits atômicos.

#### Requisitos de DevOps em análise de dados

Como comentei no início, posições como Cientista de dados, Machine Learning Engineer ou ainda AI Enginner, estão cada vez mais relacionadas com DevOps, pois um dashboard ou um modelo que precisa ser colocado em produção se beneficia de conceitos de desenvolvimento de software para que seja eficiente. Dependendo da sua rotina na empresa atual, pode ser que não sinta tanto isso, então aqui estão alguns exemplos, muito comuns, de aplicação desses conceitos DevOps, no nosso mundo de dados.

**1. CI/CD:** Quando um cientista de dados colabora num projeto que está dentro do Git, ou outra ferramenta de controle de versionamento, é necessário garantir a integração e deploy limpos, para tal, é necessário commitar com frequência, a cada nova iteração completa.

**2. Controle de versão:** Cada versão completa do projeto é registrada e pode ser resgatada. Já deve ter acontecido com você de baixar algum pacote e descobrir que precisa atualizar vários outros para poder usa-lo, pois apenas certas versões conversam entre si. Isso garante segurança e flexibilidade para os usuários. Facilidade também é outro ponto importante, é possível que o usuário use uma versão anterior de certo pacote, ao invés de atualizar vários outros

**3. Teste e monitoramento:** Unit tests ainda não é tão comum entre data scientists, mas um MLengineer que trabalha com Azure, por exemplo, perceberá que num autoML, e outros serviços, são gerados os `jobs`, que permitem o monitoramento do que está acontecendo em cada um deles, além disso o Azure ainda possui seu próprio serviço de DevOps, onde testes podem ser configurados e rodam automaticamente cada vez que um commit novo é feito lá dentro.

**4. Conteinerização:** Ferramentas como Docker estão cada vez mais comuns em aplicações de dados, pois asseguram a consistência quando é necessário atuar em diferentes computadores.

#### Resumo da ópera/Como fazer commits atômicos

**1. Keep it small:** Sempre analise se a solução que você quer aplicar pode ser quebrada em partes, se sim, cada parte deve se tornar um commit.

**2. Descrições claras:** Sempre use descrições concisas, explicando o racional por trás do seu commit.

**3. Teste antes:** Garanta que seu commit não irá quebrar nada que está funcionando.
